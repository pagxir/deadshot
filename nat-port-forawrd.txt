长消息分片
fregment0
fregment1
fregment2 | DontFregment | LastFregment

真正UDP的端口转发。
使用延时确认。

当接收到数据时，启动一个定时器。
如果定时器超时，则发送确认。
如果没超时前，再次接收到数据，则重置定时器。

发送端，发送数据后，就启动一个定时器(提供接口发送不需要定时器的)。
如果定时器超时前没有收到确认，则发送请求确认控制包。
为了避免包的重复，这个包不会被重发，除非声明这个包是可以重发的。
如果这段期间，又发送了另外的包，则重置定时器。

空闲一段时间后，由于 NAT的原因可能导致链路失效。
所以发送端多次重复后也没有接收到确认，
那么可以通过可靠链路要求重新激活链路。

使用方式
1、调用同步打开方式。
2、取消带宽的硬编码限制。
3、性能优化，去掉network busy的处理。收包的时候自动重试。

链路激活算法：
1、发起方，发送链路激活请求，并携带src_ident。
2、接收方发送激活应答，并发送回src_ident。
3、发起方，接收方边交换路由信息
(这些路由信息应该包含步骤1，2中发送的src_ident以便减少状态维护)，边发送UDP请求
4、需要根据优先级来决定是否发送更新路由表请求。
5、UDP收到请求后，执行应答。
6、用于链路激活的UDP包使用STUN协议,并用魔数来来区分普通的TCP包。
7、如果时间超过了30,60秒，那么重新获取外网地址。
8、接收到外网地址的响应后，则更新外网的时间鹾，并且唤醒等待的处理。
9、tcp链接发现链路失效则发送重新激活请求(
发送超时，并且收到最后一个包时间超过了30秒或者本机最后发送的数据时间超过了30秒)。

对端的表示方式：
方式1、使用整数来表示(可以加上仅仅由SYN包携带)。
方式2、使用字符串表示并仅仅由SYN包携带。
客户端维护一个整数与jid的对应路由表，定期删除不活动的条目(30秒一个周期),
客户端发送数据时候，利用系列号跟踪路由条目，在利用传统方式更新RTT后可以更新路由条目。


地址使用整数来表示称为src_ident,由实例启动的时候初始化为一个固定的值。
每个数据包都需要包含这个src_ident，这个整数是可以用来防止TCP劫持，校验来源的正确性。
劫持者只有跟踪整个完整的过程才能劫持连接，所以难度变大。 
TCP的路由使用自己的UDP源路由表，除了因为防止不同的实例使用相同的src_ident外产生的干扰外，还可以用于保持UDP的活动性。 客户端维护一个整数与jid的对应路由表，定期删除不活动的条目(30秒一个周期), 客户端发送数据时候，利用系列号跟踪路由条目，在利用传统方式更新RTT后可以更新路由条目。

src_ident的分配算法：
src_ident是一个32位整数，生成时分为两个16位整数，
高16位表示秒数，低16位表示分配的值(每分配一个则加一)。
对端发起连接时，不能使用超过4小时的src_ident。分配方，每秒只能分配64K个id。
对端应该对分配的src_ident进行缓存，缓存大小建议是32K，如果无法容纳更多的，则丢掉。

NAT外网地址保活维护算法:
作用，用于检测己方的外网地址还处于活跃状态(就是外网映射没有变动)。
方式一、让对方在每个发生出去的包中携带目标地址，己方根据携带信息来判定(需要修改协议)。
方式二、走另外的协议，由己方根据需要每隔一段时间就发送请求。
为了减少不必要的CPU消耗，程序应该每隔一段时间才进行一次采样。

